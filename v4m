#!/bin/bash

# v4m - VM Manager for macOS
# Usage: v4m <command> [options]

set -e

cleanup() {
    tput cnorm 2>/dev/null || true
}
trap cleanup EXIT INT TERM

V4M_DIR="$HOME/.v4m"
DISTROS_DIR="$V4M_DIR/distros"
VMS_DIR="$V4M_DIR/vms"
DEFAULT_DISTRO="debian12"
DEFAULT_USER="user01"
DEFAULT_MEMORY="4096"
DEFAULT_CPUS="4"
DEFAULT_DISK_SIZE="20G"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
GRAY='\033[0;90m'
NC='\033[0m'

show_spinner() {
    local message="$1"
    local duration="${2:-30}"
    local spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spin_length=${#spin}
    
    tput civis
    for i in $(seq 1 $duration); do
        local spinner_char=$((i % spin_length))
        printf "\r${BLUE}${spin:$spinner_char:1}${NC} $message "
        sleep 0.033
    done
    tput cnorm
}

log_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "This operation requires sudo privileges"
        exit 1
    fi
}

init_dirs() {
    mkdir -p "$DISTROS_DIR" "$VMS_DIR"
}

generate_vm_name() {
    local adjectives=("fast" "quick" "smart" "bright" "cool" "swift" "agile" "sharp" "clever" "rapid")
    local nouns=("vm" "box" "node" "server" "instance" "machine" "host" "system" "unit" "engine")
    local adj=${adjectives[$RANDOM % ${#adjectives[@]}]}
    local noun=${nouns[$RANDOM % ${#nouns[@]}]}
    local num=$((RANDOM % 100))
    echo "${adj}-${noun}-${num}"
}

generate_password() {
    openssl rand -base64 12 | tr -d "=+/" | cut -c1-12
}

sanitize_vm_name() {
    local name="$1"
    echo "$name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g'
}

get_distro_url() {
    case "$1" in
        "debian12")
            echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-arm64.qcow2"
            ;;
        "ubuntu22")
            echo "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64.img"
            ;;
        "ubuntu24")
            echo "https://cloud-images.ubuntu.com/releases/24.04/release/ubuntu-24.04-server-cloudimg-arm64.img"
            ;;
        *)
            echo ""
            ;;
    esac
}

generate_mac() {
    printf "52:54:00:%02x:%02x:%02x\n" $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

hash_password() {
    local password="$1"
    openssl passwd -6 "$password"
}

# VM Commands
vm_create() {
    local vm_name=""
    local distro="$DEFAULT_DISTRO"
    local username="$DEFAULT_USER"
    local password=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name) vm_name="$2"; shift 2 ;;
            --distro) distro="$2"; shift 2 ;;
            --user) username="$2"; shift 2 ;;
            --pass) password="$2"; shift 2 ;;
            *) log_error "Unknown option: $1"; exit 1 ;;
        esac
    done
    
    if [ -z "$vm_name" ]; then
        vm_name=$(generate_vm_name)
    else
        local original_name="$vm_name"
        vm_name=$(sanitize_vm_name "$vm_name")
        if [ "$original_name" != "$vm_name" ]; then
            log_warning "VM name sanitized: '$original_name' → '$vm_name'"
        fi
    fi
    
    if [ -z "$password" ]; then
        password=$(generate_password)
    fi
    
    check_root
    init_dirs
    
    if ! command -v qemu-system-aarch64 >/dev/null 2>&1; then
        log_error "QEMU not found. Install with: brew install qemu"
        exit 1
    fi
    
    create_vm_internal "$vm_name" "$distro" "$username" "$password"
}

get_vm_ip() {
    local vm_name="$1"
    local ip=""
    
    # Try ping to vm_name.local (mDNS)
    if ping -c 1 -W 1000 "$vm_name.local" >/dev/null 2>&1; then
        ip=$(ping -c 1 "$vm_name.local" 2>/dev/null | head -1 | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}')
    fi
    
    echo "$ip"
}

get_vm_disk_info() {
    local vm_dir="$1"
    local vm_disk="$vm_dir/disk.qcow2"
    local size_info=""
    local usage_info=""
    
    if [ -f "$vm_disk" ]; then
        # Get actual disk size (allocated)
        usage_info=$(du -h "$vm_disk" 2>/dev/null | cut -f1)
        
        # Get virtual disk size using qemu-img info
        if command -v qemu-img >/dev/null 2>&1; then
            size_info=$(qemu-img info "$vm_disk" 2>/dev/null | grep 'virtual size' | cut -d'(' -f2 | cut -d' ' -f1)
            # Convert bytes to human readable if it's just a number
            if [[ "$size_info" =~ ^[0-9]+$ ]]; then
                size_info=$(echo "$size_info" | awk '{print ($1/1024/1024/1024)"G"}')
            fi
        fi
        
        # Fallback to configured size if qemu-img fails
        if [ -z "$size_info" ]; then
            size_info="20G"  # Default size
        fi
    else
        size_info="-"
        usage_info="-"
    fi
    
    echo "$size_info|$usage_info"
}

vm_list() {
    init_dirs
    echo -e "\n${YELLOW}Virtual Machines:${NC}\n"
    
    if [ ! "$(ls -A "$VMS_DIR" 2>/dev/null)" ]; then
        echo "  No VMs found"
        return
    fi
    
    # Table header
    printf "%-15s %-10s %-5s %-8s %-10s %-10s %-15s %-10s\n" "NAME" "DISTRO" "CPUS" "MEMORY" "DISK SIZE" "DISK USED" "IP" "STATUS"
    printf "%-15s %-10s %-5s %-8s %-10s %-10s %-15s %-10s\n" "----" "------" "-----" "------" "---------" "---------" "--" "------"
    
    for vm_dir in "$VMS_DIR"/*; do
        if [ -d "$vm_dir" ]; then
            local vm_name=$(basename "$vm_dir")
            local vm_info="$vm_dir/vm-info.json"
            local pid_file="$vm_dir/vm.pid"
            
            if [ -f "$vm_info" ]; then
                local distro=$(grep '"distro"' "$vm_info" | cut -d'"' -f4)
                local cpus=$(grep '"cpus"' "$vm_info" | cut -d'"' -f4)
                local memory_mb=$(grep '"memory"' "$vm_info" | cut -d'"' -f4)
                local ip="-"
                local status="stopped"
                
                # Convert memory from MB to GB
                local memory_gb=$((memory_mb / 1024))
                if [ $memory_gb -eq 0 ]; then
                    memory_gb="<1GB"
                else
                    memory_gb="${memory_gb}GB"
                fi
                
                # Get disk information
                local disk_info=$(get_vm_disk_info "$vm_dir")
                local disk_size=$(echo "$disk_info" | cut -d'|' -f1)
                local disk_usage=$(echo "$disk_info" | cut -d'|' -f2)
                
                if [ -f "$pid_file" ] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
                    status="${GREEN}running${NC}"
                    ip=$(get_vm_ip "$vm_name")
                    [ -z "$ip" ] && ip="-"
                else
                    status="${GRAY}stopped${NC}"
                fi
                
                printf "%-15s %-10s %-5s %-8s %-10s %-10s %-15s %b\n" "$vm_name" "$distro" "$cpus" "$memory_gb" "$disk_size" "$disk_usage" "$ip" "$status"
            fi
        fi
    done
}

vm_start() {
    local vm_name="$1"
    if [ -z "$vm_name" ]; then
        log_error "VM name required"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM '$vm_name' not found"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    if [ -f "$pid_file" ] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        log_warning "VM '$vm_name' is already running"
        return
    fi
    
    check_root
    
    local vm_info="$vm_dir/vm-info.json"
    local vm_mac=$(grep '"mac"' "$vm_info" | cut -d'"' -f4)
    
    start_vm_internal "$vm_name" "$vm_mac" "$vm_dir"
}

vm_stop() {
    local vm_name="$1"
    if [ -z "$vm_name" ]; then
        log_error "VM name required"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    local pid_file="$vm_dir/vm.pid"
    
    if [ ! -f "$pid_file" ]; then
        log_warning "VM '$vm_name' is not running"
        return
    fi
    
    local pid=$(cat "$pid_file")
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid"
        rm -f "$pid_file"
        log_success "VM '$vm_name' stopped"
    else
        rm -f "$pid_file"
        log_warning "VM '$vm_name' was not running"
    fi
}

vm_delete() {
    local vm_name="$1"
    if [ -z "$vm_name" ]; then
        log_error "VM name required"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM '$vm_name' not found"
        exit 1
    fi
    
    # Check if VM is running
    local pid_file="$vm_dir/vm.pid"
    if [ -f "$pid_file" ] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        log_warning "VM '$vm_name' is currently running"
        printf "Stop and delete VM '$vm_name'? This action cannot be undone (y/N): "
        read -r confirm
        
        if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
            log_info "Stopping VM '$vm_name'..."
            vm_stop "$vm_name"
        else
            log_info "Delete cancelled"
            exit 0
        fi
    else
        printf "Delete VM '$vm_name'? This action cannot be undone (y/N): "
        read -r confirm
        
        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            log_info "Delete cancelled"
            exit 0
        fi
    fi
    
    rm -rf "$vm_dir"
    log_success "VM '$vm_name' deleted"
}

# Image Commands
image_list() {
    init_dirs
    echo -e "${YELLOW}Available Images:${NC}"
    
    if [ ! "$(ls -A "$DISTROS_DIR" 2>/dev/null)" ]; then
        echo "  No images found"
        return
    fi
    
    for distro_dir in "$DISTROS_DIR"/*; do
        if [ -d "$distro_dir" ]; then
            local distro_name=$(basename "$distro_dir")
            local image_file=$(ls "$distro_dir"/*.qcow2 "$distro_dir"/*.img 2>/dev/null | head -1)
            
            if [ -n "$image_file" ]; then
                local size=$(du -h "$image_file" | cut -f1)
                echo "  📦 $distro_name ($size)"
            fi
        fi
    done
}

image_pull() {
    local distro="$1"
    if [ -z "$distro" ]; then
        log_error "Distro name required (debian12, ubuntu22, ubuntu24)"
        exit 1
    fi
    
    init_dirs
    ensure_distro "$distro" >/dev/null
}

image_delete() {
    local distro="$1"
    if [ -z "$distro" ]; then
        log_error "Distro name required"
        exit 1
    fi
    
    local distro_dir="$DISTROS_DIR/$distro"
    if [ ! -d "$distro_dir" ]; then
        log_error "Image '$distro' not found"
        exit 1
    fi
    
    rm -rf "$distro_dir"
    log_success "Image '$distro' deleted"
}

# Internal functions
ensure_distro() {
    local distro="$1"
    local url=$(get_distro_url "$distro")
    
    if [ -z "$url" ]; then
        log_error "Unknown distro: $distro"
        log_info "Available distros: debian12, ubuntu22, ubuntu24"
        exit 1
    fi
    
    local filename=$(basename "$url")
    local distro_dir="$DISTROS_DIR/$distro"
    local distro_path="$distro_dir/$filename"
    
    if [ -f "$distro_path" ]; then
        echo "$distro_path"
        return
    fi
    
    show_spinner "Downloading $distro" 100 &
    local spinner_pid=$!
    mkdir -p "$distro_dir"
    if curl -L -o "$distro_path" "$url" --silent; then
        kill $spinner_pid 2>/dev/null
        printf "\r\033[K"
        log_success "Downloaded $distro"
        echo "$distro_path"
    else
        kill $spinner_pid 2>/dev/null
        printf "\r\033[K"
        log_error "Failed to download $distro"
        rm -f "$distro_path"
        exit 1
    fi
}

create_cloud_init() {
    local vm_name="$1"
    local username="$2"
    local password="$3"
    local vm_dir="$4"
    
    local hashed_pass=$(hash_password "$password")
    
    cat > "$vm_dir/user-data" << EOF
#cloud-config

hostname: $vm_name
fqdn: $vm_name.local
timezone: Europe/Rome

ssh_pwauth: true
disable_root: false

network:
  version: 2
  ethernets:
    enp0s1:
      dhcp4: true
      dhcp6: true

users:
  - name: $username
    sudo: ALL=(ALL) NOPASSWD:ALL
    groups: [sudo, users]
    shell: /bin/bash
    lock_passwd: false
    passwd: $hashed_pass
  - name: root
    lock_passwd: false
    passwd: $hashed_pass

packages:
  - openssh-server
  - sudo
  - curl
  - wget
  - vim
  - net-tools
  - htop
  - avahi-daemon
  - avahi-utils

runcmd:
  - systemctl enable ssh
  - systemctl start ssh
  - systemctl enable avahi-daemon
  - systemctl start avahi-daemon
  - echo "VM is ready!" > /tmp/vm-ready

final_message: "VM $vm_name is ready! SSH available on port 22."
EOF

    cat > "$vm_dir/meta-data" << EOF
instance-id: $vm_name-$(date +%s)
local-hostname: $vm_name
EOF
}

create_vm_internal() {
    local vm_name="$1"
    local distro="$2"
    local username="$3"
    local password="$4"
    
    local distro_path=$(ensure_distro "$distro")
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ -d "$vm_dir" ]; then
        log_error "VM $vm_name already exists"
        exit 1
    fi
    mkdir -p "$vm_dir"
    
    local vm_disk="$vm_dir/disk.qcow2"
    cp "$distro_path" "$vm_disk"
    qemu-img resize "$vm_disk" "$DEFAULT_DISK_SIZE" >/dev/null
    
    local vm_mac=$(generate_mac)
    
    local efi_vars="$vm_dir/efi-vars.fd"
    if [ -f "/opt/homebrew/share/qemu/edk2-aarch64-vars.fd" ]; then
        cp "/opt/homebrew/share/qemu/edk2-aarch64-vars.fd" "$efi_vars"
    else
        dd if=/dev/zero of="$efi_vars" bs=1M count=64 >/dev/null 2>&1
    fi
    
    create_cloud_init "$vm_name" "$username" "$password" "$vm_dir"
    
    local cloud_init_iso="$vm_dir/cloud-init.iso"
    local temp_dir="/tmp/cloud-init-$$"
    mkdir -p "$temp_dir"
    cp "$vm_dir/user-data" "$vm_dir/meta-data" "$temp_dir/"
    
    if ! hdiutil makehybrid -iso -joliet -default-volume-name "cidata" -o "$cloud_init_iso" "$temp_dir" >/dev/null 2>&1; then
        log_error "Failed to create cloud-init ISO"
        rm -rf "$temp_dir" "$vm_dir"
        exit 1
    fi
    rm -rf "$temp_dir"
    
    cat > "$vm_dir/vm-info.json" << EOF
{
    "name": "$vm_name",
    "distro": "$distro",
    "username": "$username",
    "password": "$password",
    "mac": "$vm_mac",
    "memory": "$DEFAULT_MEMORY",
    "cpus": "$DEFAULT_CPUS",
    "disk_size": "$DEFAULT_DISK_SIZE",
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
    
    start_vm_internal "$vm_name" "$vm_mac" "$vm_dir"
}

start_vm_internal() {
    local vm_name="$1"
    local vm_mac="$2"
    local vm_dir="$3"
    
    local vm_disk="$vm_dir/disk.qcow2"
    local cloud_init_iso="$vm_dir/cloud-init.iso"
    local efi_vars="$vm_dir/efi-vars.fd"
    local log_file="$vm_dir/console.log"
    local monitor_socket="$vm_dir/monitor.sock"
    local pid_file="$vm_dir/vm.pid"
    
    local bridge_interface=$(route get default | grep interface | awk '{print $2}')
    if [ -z "$bridge_interface" ]; then
        bridge_interface="en0"
    fi
    
    > "$log_file"
    rm -f "$monitor_socket"
    
    # For subsequent starts, don't attach cloud-init ISO to avoid reinitialization
    if [ -f "$vm_dir/.first_boot_complete" ]; then
        # VM has been booted before, don't use cloud-init
        nohup qemu-system-aarch64 \
            -machine virt \
            -cpu host \
            -accel hvf \
            -smp "$DEFAULT_CPUS" \
            -m "$DEFAULT_MEMORY" \
            -drive if=pflash,format=raw,file=/opt/homebrew/share/qemu/edk2-aarch64-code.fd,readonly=on \
            -drive if=pflash,format=raw,file="$efi_vars" \
            -drive file="$vm_disk",format=qcow2,if=virtio \
            -netdev vmnet-bridged,id=net0,ifname="$bridge_interface" \
            -device virtio-net,netdev=net0,mac="$vm_mac" \
            -global PIIX4_PM.disable_s3=1 \
            -monitor unix:"$monitor_socket",server,nowait \
            -serial unix:"$vm_dir/console.sock",server,nowait \
            -device virtio-serial \
            -chardev socket,path="$vm_dir/qga.sock",server=on,wait=off,id=qga0 \
            -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 \
            -nographic > "$log_file" 2>&1 &
    else
        # First boot, use cloud-init and mark as complete
        touch "$vm_dir/.first_boot_complete"
        nohup qemu-system-aarch64 \
            -machine virt \
            -cpu host \
            -accel hvf \
            -smp "$DEFAULT_CPUS" \
            -m "$DEFAULT_MEMORY" \
            -drive if=pflash,format=raw,file=/opt/homebrew/share/qemu/edk2-aarch64-code.fd,readonly=on \
            -drive if=pflash,format=raw,file="$efi_vars" \
            -drive file="$vm_disk",format=qcow2,if=virtio \
            -drive file="$cloud_init_iso",media=cdrom,if=virtio,readonly=on \
            -netdev vmnet-bridged,id=net0,ifname="$bridge_interface" \
            -device virtio-net,netdev=net0,mac="$vm_mac" \
            -global PIIX4_PM.disable_s3=1 \
            -monitor unix:"$monitor_socket",server,nowait \
            -serial unix:"$vm_dir/console.sock",server,nowait \
            -device virtio-serial \
            -chardev socket,path="$vm_dir/qga.sock",server=on,wait=off,id=qga0 \
            -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 \
            -nographic > "$log_file" 2>&1 &
    fi
    
    local qemu_pid=$!
    echo $qemu_pid > "$pid_file"
    disown $qemu_pid
    
    local boot_time=200
    local spin='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local spin_length=${#spin}
    
    tput civis
    for i in $(seq 1 $boot_time); do
        local spinner_char=$((i % spin_length))
        printf "\r${BLUE}${spin:$spinner_char:1}${NC} Starting VM $vm_name (may take up to 1 minute)..."
        sleep 0.1
        
        if ! kill -0 "$qemu_pid" 2>/dev/null; then
            printf "\r\033[K"
            tput cnorm
            log_error "VM $vm_name stopped unexpectedly"
            log_info "Check log: $log_file"
            exit 1
        fi
    done
    tput cnorm
    
    printf "\r\033[K"
    log_success "VM $vm_name is ready!"
    
    show_vm_info "$vm_name" "$vm_dir"
}

show_vm_info() {
    local vm_name="$1"
    local vm_dir="$2"
    local vm_info="$vm_dir/vm-info.json"
    
    if [ ! -f "$vm_info" ]; then
        log_error "VM info file not found"
        return
    fi
    
    local username=$(grep '"username"' "$vm_info" | cut -d'"' -f4)
    local password=$(grep '"password"' "$vm_info" | cut -d'"' -f4)
    
    echo
    echo -e "${YELLOW}VM Information:${NC}"
    echo "  🖥️  Name: $vm_name"
    echo "  💾 Memory: ${DEFAULT_MEMORY}MB"
    echo "  🔧 CPUs: $DEFAULT_CPUS"
    echo
    echo -e "${YELLOW}Login Credentials:${NC}"
    echo "  👤 Username: $username"
    echo "  🔑 Password: $password"
    echo "  👑 Root password: $password (same as user)"
    echo "  📺 SSH: ssh $username@$vm_name.local"
    echo
    echo -e "${YELLOW}VM Management:${NC}"
    echo "  ⏹️  Stop: v4m vm stop $vm_name"
    echo
}

show_help() {
    echo "v4m - VM Manager for macOS"
    echo
    echo "Usage: v4m <command> [options]"
    echo
    echo "VM Commands:"
    echo "  vm create [--name NAME] [--distro DISTRO] [--user USER] [--pass PASS]"
    echo "  vm list                     List all VMs"
    echo "  vm start <name>             Start a VM"
    echo "  vm stop <name>              Stop a VM"
    echo "  vm delete <name>            Delete a VM"
    echo
    echo "Image Commands:"
    echo "  image list                  List available images"
    echo "  image pull <distro>         Download a distro image"
    echo "  image delete <distro>       Delete a distro image"
    echo
    echo "Available distros: debian12, ubuntu22, ubuntu24"
    echo
    echo "Examples:"
    echo "  sudo v4m vm create                    # Create VM with defaults"
    echo "  sudo v4m vm create --name myvm        # Create VM with specific name"
    echo "  v4m vm list                           # List all VMs"
    echo "  sudo v4m vm start myvm                # Start a VM"
    echo "  v4m vm stop myvm                      # Stop a VM"
    echo "  v4m image pull ubuntu22               # Download Ubuntu 22.04 image"
}

main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    case "$1" in
        "vm")
            shift
            case "$1" in
                "create") shift; vm_create "$@" ;;
                "list") vm_list ;;
                "start") shift; vm_start "$@" ;;
                "stop") shift; vm_stop "$@" ;;
                "delete") shift; vm_delete "$@" ;;
                *) log_error "Unknown vm command: $1"; show_help; exit 1 ;;
            esac
            ;;
        "image")
            shift
            case "$1" in
                "list") image_list ;;
                "pull") shift; image_pull "$@" ;;
                "delete") shift; image_delete "$@" ;;
                *) log_error "Unknown image command: $1"; show_help; exit 1 ;;
            esac
            ;;
        "-h"|"--help"|"help")
            show_help
            ;;
        *)
            log_error "Unknown command: $1"
            show_help
            exit 1
            ;;
    esac
}

main "$@"