#!/bin/bash

# v4m - Docker-like CLI for VM management on macOS
# Manages Linux distributions and VMs with QEMU and cloud-init

set -e

# Configuration directories
V4M_DIR="$HOME/.v4m"
DISTROS_DIR="$V4M_DIR/distros"
VMS_DIR="$V4M_DIR/vms"
CONFIGS_DIR="$V4M_DIR/configs"

# Default VM specs
DEFAULT_MEMORY="4096"
DEFAULT_CPUS="4"
DEFAULT_DISK_SIZE="20G"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Initialize v4m directories
init_v4m() {
    mkdir -p "$DISTROS_DIR" "$VMS_DIR" "$CONFIGS_DIR"
}

# Available distributions - using functions for compatibility
get_distro_url() {
    case "$1" in
        "debian12")
            echo "https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-arm64.qcow2"
            ;;
        "ubuntu22")
            echo "https://cloud-images.ubuntu.com/releases/22.04/release/ubuntu-22.04-server-cloudimg-arm64.img"
            ;;
        "ubuntu24")
            echo "https://cloud-images.ubuntu.com/releases/24.04/release/ubuntu-24.04-server-cloudimg-arm64.img"
            ;;
        "fedora39")
            echo "https://download.fedoraproject.org/pub/fedora/linux/releases/39/Cloud/aarch64/images/Fedora-Cloud-Base-39-1.5.aarch64.qcow2"
            ;;
        *)
            echo ""
            ;;
    esac
}

get_distro_list() {
    echo "debian12 ubuntu22 ubuntu24 fedora39"
}

# Check QEMU availability
check_qemu() {
    if ! command -v qemu-system-aarch64 >/dev/null 2>&1; then
        log_error "QEMU not found. Please install QEMU:"
        log_error "  brew install qemu"
        exit 1
    fi
}

# Generate random MAC address
generate_mac_address() {
    printf "52:54:00:%02x:%02x:%02x\n" $((RANDOM%256)) $((RANDOM%256)) $((RANDOM%256))
}

# Query QEMU monitor for VM information
query_qemu_monitor() {
    local vm_name="$1"
    local command="$2"
    local vm_dir="$VMS_DIR/$vm_name"
    local monitor_socket="$vm_dir/monitor.sock"
    
    if [ ! -S "$monitor_socket" ]; then
        return 1
    fi
    
    if ! command -v socat >/dev/null 2>&1; then
        return 1
    fi
    
    # Send command to QEMU monitor and capture output
    echo "$command" | socat - "UNIX-CONNECT:$monitor_socket" 2>/dev/null | tail -n +2 | head -n -1
}

# Get VM network information from QEMU monitor
get_vm_network_info() {
    local vm_name="$1"
    local network_info=""
    
    # Try to get network information using info network
    network_info=$(query_qemu_monitor "$vm_name" "info network")
    
    if [ -n "$network_info" ]; then
        echo "$network_info"
        return 0
    fi
    
    # Alternative: try info qtree for network devices
    network_info=$(query_qemu_monitor "$vm_name" "info qtree" | grep -A5 -B5 "virtio-net")
    
    echo "$network_info"
}

# Get VM status from QEMU monitor
get_vm_qemu_status() {
    local vm_name="$1"
    local status=""
    
    # Get VM status
    status=$(query_qemu_monitor "$vm_name" "info status")
    
    if echo "$status" | grep -q "running"; then
        echo "running"
    elif echo "$status" | grep -q "paused"; then
        echo "paused"
    elif echo "$status" | grep -q "stopped"; then
        echo "stopped"
    else
        echo "unknown"
    fi
}

# Extract IP from QEMU guest agent (if available)
get_vm_guest_ip() {
    local vm_name="$1"
    local vm_dir="$VMS_DIR/$vm_name"
    local qga_socket="$vm_dir/qga.sock"
    local guest_info=""
    
    # Check if guest agent socket exists
    if [ ! -S "$qga_socket" ]; then
        return 1
    fi
    
    if ! command -v socat >/dev/null 2>&1; then
        return 1
    fi
    
    # Try to get guest network interfaces via QEMU guest agent
    # Send QMP command to guest agent
    guest_info=$(echo '{"execute": "guest-network-get-interfaces"}' | socat - "UNIX-CONNECT:$qga_socket" 2>/dev/null)
    
    if [ -n "$guest_info" ]; then
        # Parse JSON-like output for IP addresses (simplified parsing)
        echo "$guest_info" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -v '127.0.0.1' | head -1
    fi
}

# Find IP by MAC address using ARP table and network scanning
find_ip_by_mac() {
    local mac_address="$1"
    local ip=""
    
    # Normalize MAC address format (lowercase, colon-separated)
    mac_address=$(echo "$mac_address" | tr 'A-F' 'a-f')
    
    # Method 1: Check ARP table
    ip=$(arp -a | grep -i "$mac_address" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
    
    # Method 2: If not in ARP table, try nmap scan on local networks
    if [ -z "$ip" ] && command -v nmap >/dev/null 2>&1; then
        # Get default gateway to determine network
        local gateway=$(route get default | grep gateway | awk '{print $2}')
        if [ -n "$gateway" ]; then
            # Extract network prefix (assumes /24)
            local network=$(echo "$gateway" | cut -d'.' -f1-3)
            
            # Scan the network quickly
            nmap -sn "${network}.0/24" >/dev/null 2>&1
            
            # Check ARP table again
            sleep 1
            ip=$(arp -a | grep -i "$mac_address" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -1)
        fi
    fi
    
    echo "$ip"
}

# Extract IP from VM log
extract_ip_from_log() {
    local log_file=$1
    local ip=""
    
    # Look for cloud-init Net device info format first (most reliable for bridged networking)
    if grep -q "Net device info" "$log_file" 2>/dev/null; then
        # Extract IPv4 address from network table, excluding broadcast and netmask addresses
        ip=$(grep -E '\|\s*(enp0s1|eth0)\s*\|\s*True\s*\|' "$log_file" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -E '^(192\.168\.|10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|169\.254\.)' | head -1)
        
        # If no private IP found, try any non-broadcast IP
        if [ -z "$ip" ]; then
            ip=$(grep -E '\|\s*(enp0s1|eth0)\s*\|\s*True\s*\|' "$log_file" | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | grep -v -E '(255\.255\.255|\.255$|^127\.)' | head -1)
        fi
    fi
    
    # Try DHCP lease messages
    if [ -z "$ip" ]; then
        ip=$(grep -oE 'bound to ([0-9]{1,3}\.){3}[0-9]{1,3}' "$log_file" | head -1 | cut -d' ' -f3)
    fi
    
    # Try systemd-networkd messages
    if [ -z "$ip" ]; then
        ip=$(grep -oE 'DHCPv4 address ([0-9]{1,3}\.){3}[0-9]{1,3}' "$log_file" | head -1 | cut -d' ' -f3)
    fi
    
    # Try generic inet pattern as fallback
    if [ -z "$ip" ]; then
        ip=$(grep -oE 'inet ([0-9]{1,3}\.){3}[0-9]{1,3}' "$log_file" | grep -v '127.0.0.1' | head -1 | cut -d' ' -f2)
    fi
    
    echo "$ip"
}

# Wait for VM to boot (simplified, no IP detection)
wait_for_vm_boot() {
    local vm_name="$1"
    local boot_time=15  # Wait 15 seconds for VM to boot
    
    # Spinner characters
    local spin='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local spin_length=${#spin}
    
    for i in $(seq 1 $boot_time); do
        local spinner_char=$((i % spin_length))
        printf "\r${BLUE}[INFO]${NC} Waiting for VM to boot ${spin:$spinner_char:1}"
        sleep 1
    done
    
    printf "\r\033[K"  # Clear spinner line
    log_success "VM $vm_name is ready!"
    echo
    echo "  ðŸ’» VM Name: $vm_name"
    echo "  ðŸ–¥ï¸  Console: v4m vm console $vm_name"
    echo "  ðŸ”§ Monitor: v4m vm monitor $vm_name"
    echo "  ðŸ“Š Status: v4m vm list"
    echo
}

# Create VM with spinner (silent creation)
create_vm_with_spinner() {
    local vm_name="$1"
    local distro_path="$2"
    local vm_dir="$3"
    local disk_size="$4"
    local memory="$5"
    local cpus="$6"
    local user_data="$7"
    local meta_data="$8"
    
    # Spinner characters
    local spin='â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â '
    local spin_length=${#spin}
    local step=0
    
    echo -n "${BLUE}[INFO]${NC} Creating VM $vm_name"
    
    # Step 1: Create VM directory
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    mkdir -p "$vm_dir" 2>/dev/null
    step=$((step + 1))
    sleep 0.1
    
    # Step 2: Copy distro image to VM disk
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    local vm_disk="$vm_dir/disk.qcow2"
    cp "$distro_path" "$vm_disk" 2>/dev/null
    step=$((step + 1))
    sleep 0.1
    
    # Step 3: Resize disk
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    qemu-img resize "$vm_disk" "$disk_size" >/dev/null 2>&1
    step=$((step + 1))
    sleep 0.1
    
    # Step 4: Generate MAC address
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    local vm_mac=$(generate_mac_address)
    step=$((step + 1))
    sleep 0.1
    
    # Step 5: Create cloud-init ISO
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    local cloud_init_iso="$vm_dir/cloud-init.iso"
    local temp_dir="/tmp/cloud-init-$$"
    mkdir -p "$temp_dir" 2>/dev/null
    cp "$user_data" "$temp_dir/user-data" 2>/dev/null
    cp "$meta_data" "$temp_dir/meta-data" 2>/dev/null
    step=$((step + 1))
    sleep 0.1
    
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    if ! hdiutil makehybrid -iso -joliet -default-volume-name "cidata" -o "$cloud_init_iso" "$temp_dir" >/dev/null 2>&1; then
        printf "\r\033[K"
        log_error "Failed to create cloud-init ISO"
        rm -rf "$temp_dir" "$vm_dir"
        exit 1
    fi
    rm -rf "$temp_dir"
    step=$((step + 1))
    sleep 0.1
    
    # Step 6: Create EFI vars
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    local efi_vars="$vm_dir/efi-vars.fd"
    if [ -f "/opt/homebrew/share/qemu/edk2-aarch64-vars.fd" ]; then
        cp "/opt/homebrew/share/qemu/edk2-aarch64-vars.fd" "$efi_vars" 2>/dev/null
    else
        dd if=/dev/zero of="$efi_vars" bs=1M count=64 >/dev/null 2>&1
    fi
    step=$((step + 1))
    sleep 0.1
    
    # Step 7: Save VM configuration
    printf "\r${BLUE}[INFO]${NC} Creating VM $vm_name ${spin:$((step % spin_length)):1}"
    local vm_config="$vm_dir/config.json"
    cat > "$vm_config" << EOF
{
    "name": "$vm_name",
    "distro": "$distro",
    "memory": "$memory",
    "cpus": "$cpus",
    "disk_size": "$disk_size",
    "mac": "$vm_mac",
    "status": "stopped",
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
EOF
    
    printf "\r\033[K"  # Clear spinner line
}

# Start VM and wait for boot (simplified)
start_vm_with_spinner() {
    local vm_name="$1"
    
    printf "${BLUE}[INFO]${NC} Starting VM $vm_name..."
    
    # Start the VM silently
    vm_start_internal_silent "$vm_name"
    
    printf "\r\033[K"  # Clear line
    log_success "VM $vm_name started successfully!"
    
    # Simple boot wait
    wait_for_vm_boot "$vm_name"
}

#
# DISTRO MANAGEMENT
#

distro_list() {
    echo -e "${CYAN}AVAILABLE DISTRIBUTIONS${NC}"
    printf "%-15s %-60s %-10s\n" "NAME" "URL" "STATUS"
    printf "%-15s %-60s %-10s\n" "----" "---" "------"
    
    for distro in $(get_distro_list); do
        local url=$(get_distro_url "$distro")
        local filename=$(basename "$url")
        local distro_path="$DISTROS_DIR/$distro/$filename"
        
        if [ -f "$distro_path" ]; then
            local size=$(du -h "$distro_path" | cut -f1)
            printf "%-15s %-60s %-10s\n" "$distro" "${url:0:60}" "Downloaded ($size)"
        else
            printf "%-15s %-60s %-10s\n" "$distro" "${url:0:60}" "Available"
        fi
    done
}

distro_pull() {
    local distro_name="$1"
    
    if [ -z "$distro_name" ]; then
        log_error "Usage: v4m distro pull <distro-name>"
        echo "Available distros: $(get_distro_list)"
        exit 1
    fi
    
    local url=$(get_distro_url "$distro_name")
    if [ -z "$url" ]; then
        log_error "Unknown distro: $distro_name"
        echo "Available distros: $(get_distro_list)"
        exit 1
    fi
    local filename=$(basename "$url")
    local distro_dir="$DISTROS_DIR/$distro_name"
    local distro_path="$distro_dir/$filename"
    
    if [ -f "$distro_path" ]; then
        log_info "Distro $distro_name already downloaded"
        return 0
    fi
    
    mkdir -p "$distro_dir"
    
    log_info "Downloading $distro_name..."
    if curl -L -o "$distro_path" "$url" --progress-bar; then
        log_success "Downloaded $distro_name to $distro_path"
    else
        log_error "Failed to download $distro_name"
        rm -f "$distro_path"
        exit 1
    fi
}

distro_rm() {
    local distro_name="$1"
    
    if [ -z "$distro_name" ]; then
        log_error "Usage: v4m distro rm <distro-name>"
        exit 1
    fi
    
    local distro_dir="$DISTROS_DIR/$distro_name"
    
    if [ ! -d "$distro_dir" ]; then
        log_error "Distro $distro_name not found"
        exit 1
    fi
    
    log_info "Removing distro $distro_name..."
    rm -rf "$distro_dir"
    log_success "Removed distro $distro_name"
}

#
# VM MANAGEMENT
#

vm_create() {
    local vm_name=""
    local distro=""
    local memory="$DEFAULT_MEMORY"
    local cpus="$DEFAULT_CPUS"
    local disk_size="$DEFAULT_DISK_SIZE"
    local user_data=""
    local meta_data=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --name)
                vm_name="$2"
                shift 2
                ;;
            --distro)
                distro="$2"
                shift 2
                ;;
            --memory)
                memory="$2"
                shift 2
                ;;
            --cpus)
                cpus="$2"
                shift 2
                ;;
            --disk)
                disk_size="$2"
                shift 2
                ;;
            --user-data)
                user_data="$2"
                shift 2
                ;;
            --meta-data)
                meta_data="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    if [ -z "$vm_name" ] || [ -z "$distro" ]; then
        log_error "Usage: v4m vm create --name <name> --distro <distro> [options]"
        echo "Options:"
        echo "  --memory <MB>     Memory in MB (default: $DEFAULT_MEMORY)"
        echo "  --cpus <count>    CPU count (default: $DEFAULT_CPUS)"
        echo "  --disk <size>     Disk size (default: $DEFAULT_DISK_SIZE)"
        echo "  --user-data <file>  User data file (default: ./user-data.yaml)"
        echo "  --meta-data <file>  Meta data file (default: ./meta-data.yaml)"
        exit 1
    fi
    
    # Check if distro is available
    local distro_url=$(get_distro_url "$distro")
    if [ -z "$distro_url" ]; then
        log_error "Unknown distro: $distro"
        echo "Available distros: $(get_distro_list)"
        exit 1
    fi
    
    # Check if VM already exists
    local vm_dir="$VMS_DIR/$vm_name"
    if [ -d "$vm_dir" ]; then
        log_error "VM $vm_name already exists"
        exit 1
    fi
    
    # Check if distro is downloaded
    local url="$distro_url"
    local filename=$(basename "$url")
    local distro_path="$DISTROS_DIR/$distro/$filename"
    
    if [ ! -f "$distro_path" ]; then
        log_info "Distro $distro not found locally, downloading..."
        distro_pull "$distro"
    fi
    
    # Default cloud-init files
    if [ -z "$user_data" ]; then
        user_data="./user-data.yaml"
    fi
    if [ -z "$meta_data" ]; then
        meta_data="./meta-data.yaml"
    fi
    
    # Check cloud-init files
    if [ ! -f "$user_data" ]; then
        log_error "User data file not found: $user_data"
        exit 1
    fi
    if [ ! -f "$meta_data" ]; then
        log_error "Meta data file not found: $meta_data"
        exit 1
    fi
    
    # Start spinner for VM creation
    create_vm_with_spinner "$vm_name" "$distro_path" "$vm_dir" "$disk_size" "$memory" "$cpus" "$user_data" "$meta_data"
    
    # Check if running with sudo - auto-start, otherwise ask
    if [ "$EUID" -eq 0 ]; then
        # Continue with spinner for VM start and wait for IP
        start_vm_with_spinner "$vm_name"
    else
        echo
        printf "Start VM now? This requires sudo for bridged networking (y/N): "
        read -r start_now
        
        if [ "$start_now" = "y" ] || [ "$start_now" = "Y" ]; then
            echo
            log_info "Starting VM with sudo (required for bridged networking)..."
            sudo "$0" vm start "$vm_name"
        else
            log_info "Start later with: sudo v4m vm start $vm_name"
            log_info "Access console with: v4m vm console $vm_name (after starting)"
        fi
    fi
}

vm_list() {
    if [ ! -d "$VMS_DIR" ] || [ -z "$(ls -A "$VMS_DIR" 2>/dev/null)" ]; then
        echo "No VMs found"
        return 0
    fi
    
    echo -e "${CYAN}VMS${NC}"
    printf "%-15s %-10s %-10s %-6s %-6s %-15s\n" "NAME" "DISTRO" "STATUS" "MEMORY" "CPUS" "MAC"
    printf "%-15s %-10s %-10s %-6s %-6s %-15s\n" "----" "------" "------" "------" "----" "---"
    
    for vm_dir in "$VMS_DIR"/*; do
        if [ ! -d "$vm_dir" ]; then continue; fi
        
        local vm_name=$(basename "$vm_dir")
        local config_file="$vm_dir/config.json"
        local pid_file="$vm_dir/vm.pid"
        local log_file="$vm_dir/console.log"
        
        if [ ! -f "$config_file" ]; then continue; fi
        
        # Parse config (simple approach without jq dependency)
        local distro=$(grep '"distro"' "$config_file" | cut -d'"' -f4)
        local memory=$(grep '"memory"' "$config_file" | cut -d'"' -f4)
        local cpus=$(grep '"cpus"' "$config_file" | cut -d'"' -f4)
        local mac=$(grep '"mac"' "$config_file" | cut -d'"' -f4)
        
        # Check if VM is running
        local status="stopped"
        
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            if kill -0 "$pid" 2>/dev/null; then
                status="running"
            else
                rm -f "$pid_file"
            fi
        fi
        
        printf "%-15s %-10s %-10s %-6s %-6s %-15s\n" \
            "$vm_name" "$distro" "$status" "${memory}MB" "$cpus" "$mac"
    done
}

vm_start_internal() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm start <vm-name>"
        exit 1
    fi
    
    # Check if running with sudo privileges for vmnet-bridged
    if [ "$EUID" -ne 0 ]; then
        log_error "VM start requires sudo privileges for vmnet-bridged networking"
        log_info "Please run: sudo $0 vm start $vm_name"
        log_info "This will give the VM a real IP address on your network"
        exit 1
    fi
    
    log_info "Using vmnet-bridged networking - VM will get real IP from your network"
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM $vm_name not found"
        exit 1
    fi
    
    # Check for any QEMU processes using this VM's disk
    local disk_check=$(pgrep -f "qemu.*$vm_name" 2>/dev/null || true)
    if [ -n "$disk_check" ]; then
        log_error "VM $vm_name may already be running or disk is locked"
        log_info "Found processes: $disk_check"
        log_info "Use 'sudo kill $disk_check' to force stop, or 'v4m vm stop $vm_name'"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            log_error "VM $vm_name is already running (PID: $pid)"
            exit 1
        else
            rm -f "$pid_file"
        fi
    fi
    
    check_qemu
    
    # Load VM config
    local config_file="$vm_dir/config.json"
    local memory=$(grep '"memory"' "$config_file" | cut -d'"' -f4)
    local cpus=$(grep '"cpus"' "$config_file" | cut -d'"' -f4)
    local mac=$(grep '"mac"' "$config_file" | cut -d'"' -f4)
    
    local vm_disk="$vm_dir/disk.qcow2"
    local cloud_init_iso="$vm_dir/cloud-init.iso"
    local efi_vars="$vm_dir/efi-vars.fd"
    local log_file="$vm_dir/console.log"
    local monitor_socket="$vm_dir/monitor.sock"
    
    log_info "Starting VM $vm_name..."
    
    # Fix permissions if files were created by sudo
    if [ ! -w "$log_file" ] 2>/dev/null; then
        if [ "$EUID" -eq 0 ]; then
            chown $(stat -f "%Su" "$vm_dir") "$log_file" 2>/dev/null || true
        else
            log_warning "Log file has restricted permissions, trying to continue..."
            sudo chown $(whoami) "$log_file" 2>/dev/null || rm -f "$log_file"
        fi
    fi
    
    > "$log_file"
    rm -f "$monitor_socket"
    
    # Detect primary network interface for bridging
    local bridge_interface=$(route get default | grep interface | awk '{print $2}')
    if [ -z "$bridge_interface" ]; then
        bridge_interface="en0"  # fallback to common WiFi interface
    fi
    
    log_info "Bridging VM to network interface: $bridge_interface"
    
    nohup qemu-system-aarch64 \
        -machine virt \
        -cpu host \
        -accel hvf \
        -smp "$cpus" \
        -m "$memory" \
        -drive if=pflash,format=raw,file=/opt/homebrew/share/qemu/edk2-aarch64-code.fd,readonly=on \
        -drive if=pflash,format=raw,file="$efi_vars" \
        -drive file="$vm_disk",format=qcow2,if=virtio \
        -drive file="$cloud_init_iso",media=cdrom,if=virtio,readonly=on \
        -netdev vmnet-bridged,id=net0,ifname="$bridge_interface" \
        -device virtio-net,netdev=net0,mac="$mac" \
        -global PIIX4_PM.disable_s3=1 \
        -monitor unix:"$monitor_socket",server,nowait \
        -serial unix:"$vm_dir/console.sock",server,nowait \
        -device virtio-serial \
        -chardev socket,path="$vm_dir/qga.sock",server=on,wait=off,id=qga0 \
        -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 \
        -nographic > "$log_file" 2>&1 &
    
    local qemu_pid=$!
    echo $qemu_pid > "$pid_file"
    disown $qemu_pid
    
    log_success "VM $vm_name started (PID: $qemu_pid)"
    log_info "VM will get a real IP from your network (same subnet as Mac)"
    log_info "Use 'v4m vm console $vm_name' to access the VM"
    log_info "Use 'v4m vm monitor $vm_name' for QEMU monitor access"
}

vm_start_internal_silent() {
    local vm_name="$1"
    local vm_dir="$VMS_DIR/$vm_name"
    
    # Check for any QEMU processes using this VM's disk
    local disk_check=$(pgrep -f "qemu.*$vm_name" 2>/dev/null || true)
    if [ -n "$disk_check" ]; then
        printf "\r\033[K"
        log_error "VM $vm_name may already be running or disk is locked"
        log_info "Found processes: $disk_check"
        log_info "Use 'sudo kill $disk_check' to force stop, or 'v4m vm stop $vm_name'"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            printf "\r\033[K"
            log_error "VM $vm_name is already running (PID: $pid)"
            exit 1
        else
            rm -f "$pid_file"
        fi
    fi
    
    check_qemu
    
    # Load VM config
    local config_file="$vm_dir/config.json"
    local memory=$(grep '"memory"' "$config_file" | cut -d'"' -f4)
    local cpus=$(grep '"cpus"' "$config_file" | cut -d'"' -f4)
    local mac=$(grep '"mac"' "$config_file" | cut -d'"' -f4)
    
    local vm_disk="$vm_dir/disk.qcow2"
    local cloud_init_iso="$vm_dir/cloud-init.iso"
    local efi_vars="$vm_dir/efi-vars.fd"
    local log_file="$vm_dir/console.log"
    local monitor_socket="$vm_dir/monitor.sock"
    
    # Fix permissions if files were created by sudo
    if [ ! -w "$log_file" ] 2>/dev/null; then
        if [ "$EUID" -eq 0 ]; then
            chown $(stat -f "%Su" "$vm_dir") "$log_file" 2>/dev/null || true
        else
            sudo chown $(whoami) "$log_file" 2>/dev/null || rm -f "$log_file"
        fi
    fi
    
    > "$log_file"
    rm -f "$monitor_socket"
    
    # Detect primary network interface for bridging
    local bridge_interface=$(route get default | grep interface | awk '{print $2}')
    if [ -z "$bridge_interface" ]; then
        bridge_interface="en0"  # fallback to common WiFi interface
    fi
    
    nohup qemu-system-aarch64 \
        -machine virt \
        -cpu host \
        -accel hvf \
        -smp "$cpus" \
        -m "$memory" \
        -drive if=pflash,format=raw,file=/opt/homebrew/share/qemu/edk2-aarch64-code.fd,readonly=on \
        -drive if=pflash,format=raw,file="$efi_vars" \
        -drive file="$vm_disk",format=qcow2,if=virtio \
        -drive file="$cloud_init_iso",media=cdrom,if=virtio,readonly=on \
        -netdev vmnet-bridged,id=net0,ifname="$bridge_interface" \
        -device virtio-net,netdev=net0,mac="$mac" \
        -global PIIX4_PM.disable_s3=1 \
        -monitor unix:"$monitor_socket",server,nowait \
        -serial unix:"$vm_dir/console.sock",server,nowait \
        -device virtio-serial \
        -chardev socket,path="$vm_dir/qga.sock",server=on,wait=off,id=qga0 \
        -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 \
        -nographic > "$log_file" 2>&1 &
    
    local qemu_pid=$!
    echo $qemu_pid > "$pid_file"
    disown $qemu_pid
}

vm_start() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm start <vm-name>"
        exit 1
    fi
    
    # Start the VM
    vm_start_internal "$vm_name"
    
    # Simple boot wait
    echo
    wait_for_vm_boot "$vm_name"
}

vm_stop() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm stop <vm-name>"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM $vm_name not found"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    if [ ! -f "$pid_file" ]; then
        log_error "VM $vm_name is not running"
        exit 1
    fi
    
    local pid=$(cat "$pid_file")
    if ! kill -0 "$pid" 2>/dev/null; then
        log_error "VM $vm_name is not running"
        rm -f "$pid_file"
        exit 1
    fi
    
    log_info "Stopping VM $vm_name..."
    
    # Try graceful shutdown via monitor
    local monitor_socket="$vm_dir/monitor.sock"
    if [ -S "$monitor_socket" ]; then
        if command -v socat >/dev/null 2>&1; then
            echo "system_powerdown" | socat - "UNIX-CONNECT:$monitor_socket" 2>/dev/null
        fi
        
        # Wait for graceful shutdown
        local wait_attempts=0
        while [ $wait_attempts -lt 30 ] && kill -0 "$pid" 2>/dev/null; do
            sleep 1
            wait_attempts=$((wait_attempts + 1))
        done
    fi
    
    # Force kill if still running
    if kill -0 "$pid" 2>/dev/null; then
        kill "$pid"
        sleep 2
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null
        fi
    fi
    
    rm -f "$pid_file"
    log_success "VM $vm_name stopped"
}

vm_rm() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm rm <vm-name>"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM $vm_name not found"
        exit 1
    fi
    
    # Stop VM if running
    local pid_file="$vm_dir/vm.pid"
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            log_info "Stopping VM $vm_name before removal..."
            vm_stop "$vm_name"
        fi
    fi
    
    log_info "Removing VM $vm_name..."
    rm -rf "$vm_dir"
    log_success "VM $vm_name removed"
}

# vm_ip function removed - use external tools or monitor commands to get IP

vm_console() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm console <vm-name>"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM $vm_name not found"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    local console_socket="$vm_dir/console.sock"
    
    if [ ! -f "$pid_file" ]; then
        log_error "VM $vm_name is not running"
        exit 1
    fi
    
    local pid=$(cat "$pid_file")
    if ! kill -0 "$pid" 2>/dev/null; then
        log_error "VM $vm_name is not running"
        rm -f "$pid_file"
        exit 1
    fi
    
    if [ ! -S "$console_socket" ]; then
        log_error "Console socket not found for VM $vm_name"
        log_info "VM may still be starting up, try again in a few seconds"
        exit 1
    fi
    
    if ! command -v socat >/dev/null 2>&1; then
        log_error "socat is required for console access"
        log_info "Install with: brew install socat"
        exit 1
    fi
    
    log_info "Connecting to VM $vm_name serial console..."
    log_info "Press Ctrl+C to exit console"
    log_warning "Note: You may need to press Enter to see the login prompt"
    echo
    
    # Connect to the VM's serial console
    socat -,echo=0,icanon=0 "UNIX-CONNECT:$console_socket"
}

vm_monitor() {
    local vm_name="$1"
    
    if [ -z "$vm_name" ]; then
        log_error "Usage: v4m vm monitor <vm-name>"
        exit 1
    fi
    
    local vm_dir="$VMS_DIR/$vm_name"
    if [ ! -d "$vm_dir" ]; then
        log_error "VM $vm_name not found"
        exit 1
    fi
    
    local pid_file="$vm_dir/vm.pid"
    local monitor_socket="$vm_dir/monitor.sock"
    
    if [ ! -f "$pid_file" ]; then
        log_error "VM $vm_name is not running"
        exit 1
    fi
    
    local pid=$(cat "$pid_file")
    if ! kill -0 "$pid" 2>/dev/null; then
        log_error "VM $vm_name is not running"
        rm -f "$pid_file"
        exit 1
    fi
    
    if [ ! -S "$monitor_socket" ]; then
        log_error "Monitor socket not found for VM $vm_name"
        exit 1
    fi
    
    if ! command -v socat >/dev/null 2>&1; then
        log_error "socat is required for monitor access"
        log_info "Install with: brew install socat"
        exit 1
    fi
    
    log_info "Connecting to VM $vm_name QEMU monitor..."
    log_info "Type 'help' for commands, 'info status' for VM status, 'quit' to exit"
    echo
    
    # Connect to QEMU monitor
    socat -,echo=0,icanon=0 "UNIX-CONNECT:$monitor_socket"
}

# Main command dispatcher
main() {
    init_v4m
    
    case "${1:-help}" in
        "distro")
            case "${2:-help}" in
                "list"|"ls")
                    distro_list
                    ;;
                "pull")
                    distro_pull "$3"
                    ;;
                "rm"|"remove")
                    distro_rm "$3"
                    ;;
                *)
                    echo "Usage: v4m distro <command>"
                    echo
                    echo "Commands:"
                    echo "  list, ls       List available distributions"
                    echo "  pull <name>    Download a distribution"
                    echo "  rm <name>      Remove a downloaded distribution"
                    ;;
            esac
            ;;
        "vm")
            case "${2:-help}" in
                "create")
                    shift 2
                    vm_create "$@"
                    ;;
                "list"|"ls")
                    vm_list
                    ;;
                "start")
                    vm_start "$3"
                    ;;
                "stop")
                    vm_stop "$3"
                    ;;
                "restart")
                    vm_stop "$3"
                    sleep 2
                    vm_start "$3"
                    ;;
                "rm"|"remove")
                    vm_rm "$3"
                    ;;
                "console")
                    vm_console "$3"
                    ;;
                "monitor")
                    vm_monitor "$3"
                    ;;
                *)
                    echo "Usage: v4m vm <command>"
                    echo
                    echo "Commands:"
                    echo "  create         Create a new VM"
                    echo "  list, ls       List VMs"
                    echo "  start <name>   Start a VM"
                    echo "  stop <name>    Stop a VM"
                    echo "  restart <name> Restart a VM"
                    echo "  rm <name>      Remove a VM"
                    echo "  console <name> Connect to VM serial console"
                    echo "  monitor <name> Connect to QEMU monitor"
                    ;;
            esac
            ;;
        "version")
            echo "v4m version 1.0.0"
            ;;
        *)
            echo "v4m - Docker-like CLI for VM management on macOS"
            echo
            echo "Usage: v4m <command>"
            echo
            echo "Commands:"
            echo "  distro    Manage Linux distributions"
            echo "  vm        Manage virtual machines"
            echo "  version   Show version"
            echo
            echo "Examples:"
            echo "  v4m distro list                    # List available distributions"
            echo "  v4m distro pull debian12           # Download Debian 12"
            echo "  sudo v4m vm create --name test --distro debian12  # Create and auto-start"
            echo "  v4m vm list                        # List VMs with status"
            echo "  sudo v4m vm start test             # Start VM"
            echo "  v4m vm console test                # Access VM console"
            ;;
    esac
}

main "$@"